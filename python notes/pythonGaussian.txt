### Finally plot the results
    
    fig, axs = plt.subplots(2, 1, sharex=True, gridspec_kw={'height_ratios':[3,1]}) # I am making a 2 x 1 row x column grid, when the first row is 3 times the height ofthe2nd
# Remove horizontal space between axes
    fig.subplots_adjust(hspace=0)
    
    fig.suptitle('fit data with 2 Gaussians'+shortf, family="serif", fontsize=12)
    plt.xlabel('wavelength / nm', family="serif", fontsize=12)
    axs[1].plot(wl,residual_2gauss,'go:',label='res')
    axs[1].legend() 
    axs[1].set_ylabel("residuals",family="serif", fontsize=12)  
    axs[0].plot(wl,absorp_bk,'b+:',label='data')
    axs[0].plot(wl,_2gaussian(wl,*popt_2gauss),'r:',label='fit')
    axs[0].legend()
    axs[0].plot(wl, gauss_peak_1, "g")
    axs[0].fill_between(wl, gauss_peak_1.min(), gauss_peak_1, facecolor="green", alpha=0.5)
    axs[0].set_ylabel("absorbance",family="serif", fontsize=12)    
    axs[0].plot(wl, gauss_peak_2, "y")
    axs[0].fill_between(wl, gauss_peak_2.min(), gauss_peak_2, facecolor="yellow", alpha=0.5)  
    
    plt.show() #This command would plot a different graph for each famplitudeG1 = np.array([])
amplitudeG2 = np.array([])

amplitude_err_G1 = np.array([])
amplitude_err_G2 = np.array([])

positionG2 = np.array([])
positionG1 = np.array([])

res = np.array([])

timestamp_raw = np.array([])

filenames=sorted(glob.glob('long\\R*.dat'))
#print(filenames)
#define each element in the filenames list as "f" and do lots of thing to each element
for f in filenames:
    shortf=f[6:11] # make a short version of each filename only including characters 6 through to 12
    #print(shortf)

    #and now take each element in the list, f, normalise to the beamcurrent making an array for each element as before
    it, it_curr = np.loadtxt(f, dtype=float, delimiter=None, skiprows=18, usecols=(1,6),  unpack=True)
    it_norm = it/it_curr*180

    #we now have a normalised bkg file and a normalised list of transmission files. next we calculate the absorbance for each element, f, in the list called filenames
    absorp=np.log10(i0_norm/it_norm)
    #print(absorp)

### attempt to fit multiple Gaussians

    #set a linear background by finding the minimum point on the curve and drawing a linear line here
    _bk=min(absorp)
    #print(_bk)
    
    #now substract thebackground from the data
    absorp_bk=absorp-_bk
    header='wavelength/nm, nor_absorb'
    #print(os.getcwd())
    os.chdir(working_dir+'\long\\normalised')
    #print(os.getcwd())
    with open(shortf+'absorp_bk.dat', mode='w') as absorb_bk_file:
        np.savetxt(absorb_bk_file,np.c_[wl,absorp_bk], delimiter=',', header=header)
    os.chdir(working_dir)
    
    
    #print(type(absorp_bk))
    #plt.plot(wl,absorp_bk)
     
    #First define what a single Gaussian looks like 
    def _1gaussian(wl,amp1,cen1,sigma1):
        return (amp1*(1/(sigma1*(np.sqrt(2*np.pi))))*(np.exp((-1.0/2.0)*(((wl-cen1)/sigma1)**2))))


    #FAnd now define a two-Gaussian function, each with x values (wl), an amplitude, a center and a Sigma
    def _2gaussian(wl,amp1,cen1,sigma1,amp2,cen2,sigma2):
        return (amp1*(1/(sigma1*(np.sqrt(2*np.pi))))*(np.exp((-1.0/2.0)*(((wl-cen1)/sigma1)**2))) + \
            amp2*(1/(sigma2*(np.sqrt(2*np.pi))))*(np.exp((-1.0/2.0)*(((wl-cen2)/sigma2)**2))))

    #now make good guesses for the value of the parameters
    #init_vals = [0.23, 0.5, 123, 5]  # for [amp, cen, wid]
    #and now ask curve fit to take these initial guesses and fit the Gaussian function to the x,y (wl, absorp) data
    #best_vals, covar = curve_fit(gaussian, wl, absorp, p0=init_vals)
        
    init_vals=[0.78, 191.1, 3, 0.05, 194.0,0.9] # for [amp1, cen1, simgma1, amp2, cen2, simgma2]
    popt_2gauss, pcov_2gauss = curve_fit(_2gaussian, wl, absorp_bk, p0=init_vals, bounds=([0.7,191,2.5,0,193,0.5],[2,192,6,0.9,194.2,1])
                                        ) #use the bonds argument to add limits to the parameters, 
                                            #the first braket gives the lower limit for all parameteres 
                                            #and the second brecket gives the upper limit
    perr_2gauss = np.sqrt(np.diag(pcov_2gauss)) # calculate the err on the fit
    residual_2gauss = absorp_bk - (_2gaussian(wl, *popt_2gauss)) # make a function to subtract the fit from the data called residuals
    residuals=sum((absorp_bk-(_2gaussian(wl, *popt_2gauss)))**2)
    res=np.append(res,(residuals))
        
    
    pars_1 = popt_2gauss[0:3] # divide the output parameteres into to arrays, one for the first Gaussian and a 2nd for Gaussian 2
    pars_2 = popt_2gauss[3:6]
    pars_err_1 = perr_2gauss[0:3] # divide the output parameteres into to arrays, one for the first Gaussian and a 2nd for Gaussian 2
    pars_err_2 = perr_2gauss[3:6]
    #Define a variable to process these fit values into as arrays:
    gauss_peak_1 = _1gaussian(wl, *pars_1)
    gauss_peak_2 = _1gaussian(wl, *pars_2)
    
### look at the results
    print('--------------G1----------------')
    print ("amplitude = %0.2f (+/-) %0.2f" % (pars_1[0], pars_err_1[0]))
    print ("center = %0.2f (+/-) %0.2f" % (pars_1[1], pars_err_1[1]))
    print ("sigma = %0.2f (+/-) %0.2f" % (pars_1[2], pars_err_1[2]))

    print('--------------G2----------------')
    print ("amplitude = %0.2f (+/-) %0.2f" % (pars_2[0], pars_err_2[0]))
    print ("center = %0.2f (+/-) %0.2f" % (pars_2[1], pars_err_2[1]))
    print ("sigma = %0.2f (+/-) %0.2f" % (pars_2[2], pars_err_2[2]))

### Now I want to export the amplitude for each element f and associate it with a timestamp
    amplitudeG1=np.append(amplitudeG1,(pars_1[0]))
    amplitude_err_G1=np.append(amplitude_err_G1,(pars_err_1[0]))
    amplitudeG2=np.append(amplitudeG2,(pars_2[0]))
    amplitude_err_G2=np.append(amplitude_err_G2,(pars_err_2[0]))
    positionG1=np.append(positionG1,(pars_1[1]))
    positionG2=np.append(positionG2,(pars_2[1]))
    
   
    #use the os command to move up and down beween directories to save the fit data
    #print(os.getcwd())
    os.chdir(working_dir+'\long')
    os.chdir(working_dir+'\long\GaussianFits')
    #print(os.getcwd())
    with open(shortf+'_fitG1.dat', mode='w') as fitfileG1:
        np.savetxt(fitfileG1,np.c_[wl,gauss_peak_1])
    with open(shortf+'_fitG2.dat', mode='w') as fitfileG2:
        np.savetxt(fitfileG2,np.c_[wl,gauss_peak_2])
    with open(shortf+'_fit.dat', mode='w') as fitfile_all:
        np.savetxt(fitfile_all,np.c_[wl,_2gaussian(wl,*popt_2gauss)])

    os.chdir(working_dir)
    #print(os.getcwd())
     
    #and associate a timestamp with each element f, note that I make the time stamp the first time value for that file, it could easily be the last instead!
    time = np.loadtxt(f, dtype=str, delimiter=None, skiprows=16, usecols=(9), unpack=True)
    a=float(get_sec(time[1]))
    timestamp_raw=np.append(timestamp_raw,(a))

            
### Finally plot the results
    
    fig, axs = plt.subplots(2, 1, sharex=True, gridspec_kw={'height_ratios':[3,1]}) # I am making a 2 x 1 row x column grid, when the first row is 3 times the height ofthe2nd
# Remove horizontal space between axes
    fig.subplots_adjust(hspace=0)
    
    fig.suptitle('fit data with 2 Gaussians'+shortf, family="serif", fontsize=12)
    plt.xlabel('wavelength / nm', family="serif", fontsize=12)
    axs[1].plot(wl,residual_2gauss,'go:',label='res')
    axs[1].legend() 
    axs[1].set_ylabel("residuals",family="serif", fontsize=12)  
    axs[0].plot(wl,absorp_bk,'b+:',label='data')
    axs[0].plot(wl,_2gaussian(wl,*popt_2gauss),'r:',label='fit')
    axs[0].legend()
    axs[0].plot(wl, gauss_peak_1, "g")
    axs[0].fill_between(wl, gauss_peak_1.min(), gauss_peak_1, facecolor="green", alpha=0.5)
    axs[0].set_ylabel("absorbance",family="serif", fontsize=12)    
    axs[0].plot(wl, gauss_peak_2, "y")
    axs[0].fill_between(wl, gauss_peak_2.min(), gauss_peak_2, facecolor="yellow", alpha=0.5)  
    
    plt.show() #This command would plot a different graph for each f
    
    fig.savefig(basename+' 2G fit to last time point', dpi=300, bbox_inches='tight')
#print(res)
#print(amplitudeG1)

